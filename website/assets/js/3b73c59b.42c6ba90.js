"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[56171],{15680:(e,t,n)=>{n.d(t,{xA:()=>d,yg:()=>g});var i=n(96540);function a(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);t&&(i=i.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,i)}return n}function r(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){a(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,i,a=function(e,t){if(null==e)return{};var n,i,a={},o=Object.keys(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||(a[n]=e[n]);return a}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(i=0;i<o.length;i++)n=o[i],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(a[n]=e[n])}return a}var l=i.createContext({}),u=function(e){var t=i.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):r(r({},t),e)),n},d=function(e){var t=u(e.components);return i.createElement(l.Provider,{value:t},e.children)},p={inlineCode:"code",wrapper:function(e){var t=e.children;return i.createElement(i.Fragment,{},t)}},c=i.forwardRef((function(e,t){var n=e.components,a=e.mdxType,o=e.originalType,l=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),c=u(n),g=a,m=c["".concat(l,".").concat(g)]||c[g]||p[g]||o;return n?i.createElement(m,r(r({ref:t},d),{},{components:n})):i.createElement(m,r({ref:t},d))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var o=n.length,r=new Array(o);r[0]=c;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,r[1]=s;for(var u=2;u<o;u++)r[u]=n[u];return i.createElement.apply(null,r)}return i.createElement.apply(null,n)}c.displayName="MDXCreateElement"},77369:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>g,frontMatter:()=>s,metadata:()=>u,toc:()=>p});var i=n(58168),a=n(98587),o=(n(96540),n(15680)),r=["components"],s={id:"audit",title:"Audit"},l=void 0,u={unversionedId:"audit",id:"audit",title:"Audit",description:"Audit performs periodic evaluations of existing resources against constraints, detecting pre-existing misconfigurations.",source:"@site/docs/audit.md",sourceDirName:".",slug:"/audit",permalink:"/gatekeeper/website/docs/next/audit",draft:!1,editUrl:"https://github.com/open-policy-agent/gatekeeper/edit/master/website/docs/audit.md",tags:[],version:"current",frontMatter:{id:"audit",title:"Audit"},sidebar:"docs",previous:{title:"How to use Gatekeeper",permalink:"/gatekeeper/website/docs/next/howto"},next:{title:"Handling Constraint Violations",permalink:"/gatekeeper/website/docs/next/violations"}},d={},p=[{value:"Reading Audit Results",id:"reading-audit-results",level:2},{value:"Prometheus Metrics",id:"prometheus-metrics",level:3},{value:"Constraint Status",id:"constraint-status",level:3},{value:"Audit Logs",id:"audit-logs",level:3},{value:"Violations",id:"violations",level:4},{value:"Other Event Types",id:"other-event-types",level:4},{value:"Export violations",id:"export-violations",level:3},{value:"Running Audit",id:"running-audit",level:2},{value:"Configuring Audit",id:"configuring-audit",level:2},{value:"Audit using kinds specified in the constraints only",id:"audit-using-kinds-specified-in-the-constraints-only",level:3},{value:"Opt-out of Audit in constraints",id:"opt-out-of-audit-in-constraints",level:3},{value:"Audit UserInfo",id:"audit-userinfo",level:2}],c={toc:p};function g(e){var t=e.components,n=(0,a.A)(e,r);return(0,o.yg)("wrapper",(0,i.A)({},c,n,{components:t,mdxType:"MDXLayout"}),(0,o.yg)("p",null,"Audit performs periodic evaluations of existing resources against constraints, detecting pre-existing misconfigurations."),(0,o.yg)("h2",{id:"reading-audit-results"},"Reading Audit Results"),(0,o.yg)("p",null,"There are three ways to gather audit results, depending on the level of detail needed."),(0,o.yg)("h3",{id:"prometheus-metrics"},"Prometheus Metrics"),(0,o.yg)("p",null,"Prometheus metrics provide an aggregated look at the number of audit violations:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"gatekeeper_audit_last_run_time")," provides the start time timestamp of the most recent audit run"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"gatekeeper_audit_last_run_end_time")," provides the end time timestamp of the last completed audit run"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"gatekeeper_violations")," provides the total number of audited violations for the last audit run, broken down by violation severity")),(0,o.yg)("h3",{id:"constraint-status"},"Constraint Status"),(0,o.yg)("p",null,"Violations of constraints are listed in the ",(0,o.yg)("inlineCode",{parentName:"p"},"status")," field of the corresponding constraint.\nNote that only violations from the most recent audit run are reported. Also note that there\nis a maximum number of individual violations that will be reported on the constraint\nitself. If the number of current violations is greater than this cap, the excess violations\nwill not be reported (though they will still be included in the ",(0,o.yg)("inlineCode",{parentName:"p"},"totalViolations")," count).\nThis is because Kubernetes has a cap on how large individual API objects can grow, which makes\nunbounded growth a bad idea. This limit can be configured via the ",(0,o.yg)("inlineCode",{parentName:"p"},"--constraint-violations-limit")," flag."),(0,o.yg)("p",null,"Here is an example of a constraint with violations:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: constraints.gatekeeper.sh/v1beta1\nkind: K8sRequiredLabels\nmetadata:\n  name: ns-must-have-gk\nspec:\n  match:\n    kinds:\n      - apiGroups: [""]\n        kinds: ["Namespace"]\n  parameters:\n    labels: ["gatekeeper"]\nstatus:\n  auditTimestamp: "2019-05-11T01:46:13Z"\n  enforced: true\n  violations:\n  - enforcementAction: deny\n    group: ""\n    version: v1\n    kind: Namespace\n    message: \'you must provide labels: {"gatekeeper"}\'\n    name: default\n  - enforcementAction: deny\n    group: ""\n    version: v1\n    kind: Namespace\n    message: \'you must provide labels: {"gatekeeper"}\'\n    name: gatekeeper-system\n  - enforcementAction: deny\n    group: ""\n    version: v1\n    kind: Namespace\n    message: \'you must provide labels: {"gatekeeper"}\'\n    name: kube-public\n  - enforcementAction: deny\n    group: ""\n    version: v1\n    kind: Namespace\n    message: \'you must provide labels: {"gatekeeper"}\'\n    name: kube-system\n')),(0,o.yg)("p",null,"Limitations of getting violations from constraint status:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"To reduce in-memory consumption of Gatekeeper audit pod and to avoid hitting ",(0,o.yg)("a",{parentName:"li",href:"https://etcd.io/docs/v3.5/dev-guide/limit/#request-size-limit"},"default etcd limit")," of 1.5MB per resource, gatekeeper recommends configuring a ",(0,o.yg)("a",{parentName:"li",href:"https://open-policy-agent.github.io/gatekeeper/website/docs/audit/#configuring-audit"},"limit up-to 500 violations"),"(by default 20) on constraint. Because of these limitations, users might not get all the violations from a Constraint resource.")),(0,o.yg)("h3",{id:"audit-logs"},"Audit Logs"),(0,o.yg)("h4",{id:"violations"},"Violations"),(0,o.yg)("p",null,"The audit pod emits JSON-formatted audit logs to stdout. The following is an example audit event:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-json"},'{\n  "level": "info",\n  "ts": 1632889070.3075402,\n  "logger": "controller",\n  "msg": "container <kube-scheduler> has no resource limits",\n  "process": "audit",\n  "audit_id": "2021-09-29T04:17:47Z",\n  "event_type": "violation_audited",\n  "constraint_group": "constraints.gatekeeper.sh",\n  "constraint_api_version": "v1beta1",\n  "constraint_kind": "K8sContainerLimits",\n  "constraint_name": "container-must-have-limits",\n  "constraint_namespace": "",\n  "constraint_action": "deny",\n  "constraint_enforcement_actions": [],\n  "constraint_annotations": {\n    "test-annotation-1": "annotation_1"\n  },\n  "resource_group": "",\n  "resource_api_version": "v1",\n  "resource_kind": "Pod",\n  "resource_namespace": "kube-system",\n  "resource_name": "kube-scheduler-kind-control-plane"\n  "resource_labels": {\n    "env": "prod",\n    "my-app-system": "true"\n  }\n}\n')),(0,o.yg)("p",null,"In addition to information on the violated constraint, violating resource, and violation message, the\naudit log entries also contain:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"An ",(0,o.yg)("inlineCode",{parentName:"li"},"audit_id")," field that uniquely identifies a given audit run. This allows indexing of historical audits"),(0,o.yg)("li",{parentName:"ul"},"An ",(0,o.yg)("inlineCode",{parentName:"li"},"event_type")," field with a value of ",(0,o.yg)("inlineCode",{parentName:"li"},"violation_audited")," to make it easy to programmatically identify audit violations")),(0,o.yg)("p",null,"Limitations of getting violations from audit logs:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"It could be difficult to parse audit pod logs to look for violation messages, as violation logs would be mixed together with other log statements.")),(0,o.yg)("h4",{id:"other-event-types"},"Other Event Types"),(0,o.yg)("p",null,"In addition to violations, these other audit events may be useful (all uniquely identified via the ",(0,o.yg)("inlineCode",{parentName:"p"},"event_type")," field):"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"audit_started")," marks the beginning of a new audit run"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"constraint_audited")," marks when a constraint is done being audited for a given run, along with the number of violations found"),(0,o.yg)("li",{parentName:"ul"},(0,o.yg)("inlineCode",{parentName:"li"},"audit_finished")," marks the end of the current audit run")),(0,o.yg)("p",null,"All of these events (including ",(0,o.yg)("inlineCode",{parentName:"p"},"violation_audited"),") are marked\nwith the same ",(0,o.yg)("inlineCode",{parentName:"p"},"audit_id")," for a given audit run."),(0,o.yg)("h3",{id:"export-violations"},"Export violations"),(0,o.yg)("p",null,"This feature allows different systems to be provided for Gatekeeper to export audit violations. Thereby, ensuring violations are not subject to reporting limits. Please refer to ",(0,o.yg)("a",{parentName:"p",href:"/gatekeeper/website/docs/next/export"},"the export guide")," to configure audit to push violations via this feature."),(0,o.yg)("p",null,"Limitations/drawbacks of exporting violations:"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"There is a risk of messages getting dropped. You might not receive all the exported violations. This depends on the type of backend you are using for delivery. For example, using a network as backend to export violation has the risk of messages getting dropped."),(0,o.yg)("li",{parentName:"ul"},"Additional dependency on the backend system provided. For example, using pubsub tools to export violations.")),(0,o.yg)("h2",{id:"running-audit"},"Running Audit"),(0,o.yg)("p",null,"For more details on how to deploy audit and\nnumber of instances to run, please refer to ",(0,o.yg)("a",{parentName:"p",href:"/gatekeeper/website/docs/next/operations#audit"},"operations audit"),". "),(0,o.yg)("h2",{id:"configuring-audit"},"Configuring Audit"),(0,o.yg)("ul",null,(0,o.yg)("li",{parentName:"ul"},"Audit violations per constraint: set ",(0,o.yg)("inlineCode",{parentName:"li"},"--constraint-violations-limit=123")," (defaults to ",(0,o.yg)("inlineCode",{parentName:"li"},"20"),"). NOTE: This flag only impacts when gathering audit results using the constraint status model. If you want to export audit results via other means, please refer to ",(0,o.yg)("a",{parentName:"li",href:"/gatekeeper/website/docs/next/export"},"the export guide"),". Both approaches for getting audit violations can be configured independently and work simultaneously without any interference."),(0,o.yg)("li",{parentName:"ul"},"Audit chunk size: set ",(0,o.yg)("inlineCode",{parentName:"li"},"--audit-chunk-size=400")," (defaults to ",(0,o.yg)("inlineCode",{parentName:"li"},"500"),", ",(0,o.yg)("inlineCode",{parentName:"li"},"0")," = infinite) Lower chunk size can reduce memory consumption of the auditing ",(0,o.yg)("inlineCode",{parentName:"li"},"Pod")," but can increase the number requests to the Kubernetes API server."),(0,o.yg)("li",{parentName:"ul"},"Audit interval: set ",(0,o.yg)("inlineCode",{parentName:"li"},"--audit-interval=123")," (defaults to every ",(0,o.yg)("inlineCode",{parentName:"li"},"60")," seconds). Disable audit interval by setting ",(0,o.yg)("inlineCode",{parentName:"li"},"--audit-interval=0")),(0,o.yg)("li",{parentName:"ul"},"Audit api server cache write to disk (Gatekeeper v3.7.0+): Starting from v3.7.0, by default, audit writes api server cache to the disk attached to the node. This reduces the memory consumption of the audit ",(0,o.yg)("inlineCode",{parentName:"li"},"pod"),". If there are concerns with high IOPS, then switch audit to write cache to a tmpfs ramdisk instead. NOTE: write to ramdisk will increase memory footprint of the audit ",(0,o.yg)("inlineCode",{parentName:"li"},"pod"),".  ",(0,o.yg)("ul",{parentName:"li"},(0,o.yg)("li",{parentName:"ul"},"helm install ",(0,o.yg)("inlineCode",{parentName:"li"},"--set audit.writeToRAMDisk=true")," "),(0,o.yg)("li",{parentName:"ul"},"if not using helm, modify the deployment manifest to mount a ramdisk",(0,o.yg)("pre",{parentName:"li"},(0,o.yg)("code",{parentName:"pre",className:"language-yaml"},"- emptyDir:\n    medium: Memory\n")))))),(0,o.yg)("p",null,"By default, audit will request each resource from the Kubernetes API during each audit cycle. To rely on the audit informer cache instead, use the flag ",(0,o.yg)("inlineCode",{parentName:"p"},"--audit-from-cache=true"),". Note that this requires replication of Kubernetes resources into the audit cache before they can be evaluated against the enforced policies. Refer to the ",(0,o.yg)("a",{parentName:"p",href:"/gatekeeper/website/docs/next/sync"},"Replicating data")," section for more information."),(0,o.yg)("h3",{id:"audit-using-kinds-specified-in-the-constraints-only"},"Audit using kinds specified in the constraints only"),(0,o.yg)("p",null,"By default, Gatekeeper will audit all resources in the cluster. This operation can take some time depending on the number of resources."),(0,o.yg)("p",null,'If all of your constraints match against specific kinds (e.g. "match only pods"), then you can speed up audit runs by setting ',(0,o.yg)("inlineCode",{parentName:"p"},"--audit-match-kind-only=true")," flag. This will only check resources of the kinds specified in all ",(0,o.yg)("a",{parentName:"p",href:"/gatekeeper/website/docs/next/howto#constraints"},"constraints")," defined in the cluster."),(0,o.yg)("p",null,"For example, defining this constraint will only audit ",(0,o.yg)("inlineCode",{parentName:"p"},"Pod")," kind:"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: constraints.gatekeeper.sh/v1beta1\nkind: K8sAllowedRepos\nmetadata:\n  name: prod-repo-is-openpolicyagent\nspec:\n  match:\n    kinds:\n      - apiGroups: [""]\n        kinds: ["Pod"]\n...\n')),(0,o.yg)("p",null,"If any of the ",(0,o.yg)("a",{parentName:"p",href:"/gatekeeper/website/docs/next/howto#constraints"},"constraints")," do not specify ",(0,o.yg)("inlineCode",{parentName:"p"},"kinds"),", it will be equivalent to not setting ",(0,o.yg)("inlineCode",{parentName:"p"},"--audit-match-kind-only")," flag (",(0,o.yg)("inlineCode",{parentName:"p"},"false")," by default), and will fall back to auditing all resources in the cluster."),(0,o.yg)("h3",{id:"opt-out-of-audit-in-constraints"},"Opt-out of Audit in constraints"),(0,o.yg)("p",null,"By default, all constraints are opted-in audit. To opt-out of the audit process at constraint, you can use ",(0,o.yg)("inlineCode",{parentName:"p"},"enforcementAction: scoped")," and define ",(0,o.yg)("inlineCode",{parentName:"p"},"scopedEnforcementActions")," without including audit enforcement point."),(0,o.yg)("p",null,"For example, defining this constraint will opt-out of audit"),(0,o.yg)("pre",null,(0,o.yg)("code",{parentName:"pre",className:"language-yaml"},'apiVersion: constraints.gatekeeper.sh/v1beta1\nkind: K8sAllowedRepos\nmetadata:\n  name: prod-repo-is-openpolicyagent\nspec:\n...\n  enforcementAction: scoped\n  scopedEnforcementActions:\n  - action: warn\n    enforcementPoints:\n    - name: "validation.gatekeeper.sh"\n  - action: deny\n    enforcementPoints:\n    - name: "gator.gatekeeper.sh"\n...\n')),(0,o.yg)("p",null,"Find out more about different ",(0,o.yg)("a",{parentName:"p",href:"/gatekeeper/website/docs/next/enforcement-points"},"enforcement points")," in Gatekeeper."),(0,o.yg)("h2",{id:"audit-userinfo"},"Audit UserInfo"),(0,o.yg)("p",null,"When using ",(0,o.yg)("inlineCode",{parentName:"p"},"input.review.userInfo"),", ",(0,o.yg)("em",{parentName:"p"},"NOTE")," the request's user's information, such as ",(0,o.yg)("inlineCode",{parentName:"p"},"username"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"uid"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"groups"),", ",(0,o.yg)("inlineCode",{parentName:"p"},"extra"),", cannot be populated by Kubernetes for audit reviews and therefore constraint templates that rely on ",(0,o.yg)("inlineCode",{parentName:"p"},"userInfo")," are not auditable. It is up to the rego author to handle the case where ",(0,o.yg)("inlineCode",{parentName:"p"},"userInfo")," is unset and empty in order to avoid every matching resource being reported as violating resources."))}g.isMDXComponent=!0}}]);